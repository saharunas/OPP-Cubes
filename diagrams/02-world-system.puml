@startuml World System - OPP Cubes
!theme plain
title World System - Generation, Storage & Management

' Compact layout configuration
skinparam defaultFontSize 10
skinparam classFontSize 10
skinparam packageFontSize 12
skinparam minClassWidth 100
skinparam nodesep 10
skinparam ranksep 20
skinparam dpi 150
skinparam backgroundColor white
' Use top-to-bottom layout for better vertical flow
!define DIRECTION top to bottom direction

package "Core World" {
    abstract class World {
        +areas : AreaMap
        +entities : EntityManager
        +lightHandler : WorldLightHandler
        +gravity : WorldGravity
        +time : long
        +rainStatus : RainStatus
        --
        +{abstract} getBlock(x : int, y : int, z : int) : Block
        +{abstract} setBlock(areaReference : AreaReference, x : int, y : int, z : int, block : Block) : void
        +getArea(areaX : int, areaZ : int) : Area
        +isAreaLoaded(areaX : int, areaZ : int) : boolean
        +save() : void
        +tick() : void
        +dispose() : void
    }

    class WorldClient {
        +player : Player
        +renderer : WorldRenderer
        --
        +create() : void
        +getBlock(x : int, y : int, z : int) : Block
        +setBlock(areaReference : AreaReference, x : int, y : int, z : int, block : Block) : void
        +updateRenderAreas() : void
    }

    class WorldServer {
        +playerManager : PlayerManager
        +loadedAreaFilter : LoadedAreaFilter
        --
        +create() : void
        +getBlock(x : int, y : int, z : int) : Block
        +setBlock(areaReference : AreaReference, x : int, y : int, z : int, block : Block) : void
        +isAreaLoadedByPlayers(areaX : int, areaZ : int) : boolean
    }

    class CoordinateConverter {
        +{static} areaX(x : float) : int
        +{static} areaZ(z : float) : int
        +{static} blockX(x : float) : int
        +{static} blockY(y : float) : int
        +{static} blockZ(z : float) : int
        +{static} area(x : float, z : float) : Vector2
        +{static} block(x : float, y : float, z : float) : Vector3
    }
}

package "World Storage" {
    class Area {
        +areaX : int
        +areaZ : int
        +blocks : int[][][]
        +blockData : Map<Vector3, BlockData>
        +entities : Entities
        +modified : boolean
        +lightWorldSection : LightWorldSection
        --
        +getBlock(x : int, y : int, z : int) : Block
        +setBlock(x : int, y : int, z : int, block : Block) : void
        +getBlockData(x : int, y : int, z : int) : BlockData
        +setBlockData(x : int, y : int, z : int, data : BlockData) : void
        +addEntity(entity : Entity) : void
        +removeEntity(entity : Entity) : void
        +save() : void
        +load() : void
    }

    class AreaMap {
        -areas : Map<Vector2, Area>
        -lock : ReentrantReadWriteLock
        --
        +getArea(areaX : int, areaZ : int) : Area
        +setArea(areaX : int, areaZ : int, area : Area) : void
        +isAreaLoaded(areaX : int, areaZ : int) : boolean
        +removeArea(areaX : int, areaZ : int) : void
        +getLoadedAreas() : Set<Vector2>
        +lock() : Lock
        +readLock() : Lock
    }

    class Entities {
        -entities : List<Entity>
        --
        +addEntity(entity : Entity) : void
        +removeEntity(entity : Entity) : void
        +getEntities() : List<Entity>
        +getEntitiesInRange(center : Vector3, radius : float) : List<Entity>
        +tick() : void
    }
}

package "World Generation" {
    abstract class TerrainGenerator {
        +name : String
        +seed : long
        --
        +{abstract} generate(area : Area, x : int, z : int) : void
        +{abstract} features(area : Area, x : int, z : int) : void
        +setBlock(area : Area, x : int, y : int, z : int, block : Block) : void
    }

    class BasicTerrainGenerator {
        +noise : OpenSimplexNoise
        +heightMap : int[][]
        --
        +generate(area : Area, x : int, z : int) : void
        +features(area : Area, x : int, z : int) : void
        -generateHeight(x : int, z : int) : int
        -generateTerrain(area : Area, x : int, z : int) : void
    }

    class SmoothWorld {
        +noise : OpenSimplexNoise
        +caveManager : CaveManager
        +treeGenerator : TreeGenerator
        --
        +generate(area : Area, x : int, z : int) : void
        +features(area : Area, x : int, z : int) : void
        -generateBiome(x : int, z : int) : Biome
    }

    class GeneratorManager {
        -{static} generators : Map<String, TerrainGenerator>
        -{static} currentGenerator : TerrainGenerator
        --
        +{static} registerGenerator(name : String, generator : TerrainGenerator) : void
        +{static} getGenerator(name : String) : TerrainGenerator
        +{static} setCurrentGenerator(name : String) : void
        +{static} getCurrentGenerator() : TerrainGenerator
    }

    class VoidTerrainGenerator {
        +generate(area : Area, x : int, z : int) : void
        +features(area : Area, x : int, z : int) : void
    }

    class TestTerrainGenerator {
        +generate(area : Area, x : int, z : int) : void
        +features(area : Area, x : int, z : int) : void
    }

    enum RainStatus {
        +CLEAR
        +LIGHT_RAIN
        +HEAVY_RAIN
        +STORM
        --
        +getIntensity() : float
    }
}

package "World Threading" {
    class WorldTasks {
        -{static} generationQueue : PriorityBlockingQueue<WorldGenerationTask>
        -{static} saveQueue : BlockingQueue<WorldSaveTask>
        --
        +{static} requestGeneration(world : World, areaX : int, areaZ : int) : void
        +{static} requestSave(area : Area) : void
        +{static} init() : void
        +{static} dispose() : void
    }

    class WorldGenerationTask {
        +world : World
        +areaX : int
        +areaZ : int
        +priority : int
        --
        +run() : void
        +getPriority() : int
        +equals(obj : Object) : boolean
        +hashCode() : int
    }

    class WorldSaveTask {
        +area : Area
        +saveData : byte[]
        --
        +run() : void
    }

    abstract class WorldLockable {
        #locked : boolean
        --
        +lock() : void
        +unlock() : void
        +isLocked() : boolean
        +{abstract} getLockName() : String
    }

    class GenerationTask {
        +areaX : int
        +areaZ : int
        +generator : TerrainGenerator
        --
        +run() : void
    }
}

package "World Lighting" {
    class WorldLightHandler {
        +world : World
        --
        +calculateLight(areaX : int, areaZ : int) : void
        +updateLightAround(x : int, y : int, z : int) : void
        +getSunlight(x : int, y : int, z : int) : int
        +getBlocklight(x : int, y : int, z : int) : int
    }

    class BlockLight {
        +{static} calculateBlockLight(area : Area, x : int, y : int, z : int) : void
        +{static} propagateBlockLight(area : Area, x : int, y : int, z : int) : void
    }

    class SunLight {
        +{static} calculateSunLight(area : Area) : void
        +{static} propagateSunLight(area : Area, x : int, y : int, z : int) : void
    }

    class LightWorldSection {
        +sunlight : byte[][][]
        +blocklight : byte[][][]
        --
        +getSunlight(x : int, y : int, z : int) : int
        +setSunlight(x : int, y : int, z : int, light : int) : void
        +getBlocklight(x : int, y : int, z : int) : int
        +setBlocklight(x : int, y : int, z : int, light : int) : void
    }

    class LightNode {
        +x : int
        +y : int
        +z : int
        +lightLevel : int
        --
        +LightNode(x : int, y : int, z : int, lightLevel : int)
        +equals(obj : Object) : boolean
        +hashCode() : int
    }
}

package "World References" {
    class AreaReference {
        +areaX : int
        +areaZ : int
        +area : Area
        --
        +getArea() : Area
        +release() : void
        +isValid() : boolean
    }

    class BlockReference {
        +areaReference : AreaReference
        +x : int
        +y : int
        +z : int
        --
        +getBlock() : Block
        +setBlock(block : Block) : void
        +getBlockData() : BlockData
        +setBlockData(data : BlockData) : void
        +release() : void
    }

    class AreaReferencePool {
        -{static} pool : Pool<AreaReference>
        --
        +{static} obtain(areaX : int, areaZ : int) : AreaReference
        +{static} free(reference : AreaReference) : void
    }

    class BlockReferencePool {
        -{static} pool : Pool<BlockReference>
        --
        +{static} obtain(areaX : int, areaZ : int, x : int, y : int, z : int) : BlockReference
        +{static} free(reference : BlockReference) : void
    }
}

' Relationships
World <|-- WorldClient
World <|-- WorldServer
World --> AreaMap : contains
World --> WorldLightHandler : uses
World --> RainStatus : has

AreaMap --> Area : manages
Area --> Entities : contains
Area --> LightWorldSection : contains

TerrainGenerator <|-- BasicTerrainGenerator
TerrainGenerator <|-- SmoothWorld
TerrainGenerator <|-- VoidTerrainGenerator
TerrainGenerator <|-- TestTerrainGenerator
GeneratorManager --> TerrainGenerator : manages
World --> GeneratorManager : uses

WorldTasks --> WorldGenerationTask : queues
WorldTasks --> WorldSaveTask : queues
WorldGenerationTask --> TerrainGenerator : uses
WorldLockable <|-- GenerationTask

WorldLightHandler --> BlockLight : uses
WorldLightHandler --> SunLight : uses
Area --> LightWorldSection : contains
LightWorldSection --> LightNode : uses

AreaReferencePool --> AreaReference : creates
BlockReferencePool --> BlockReference : creates
BlockReference --> AreaReference : uses

note right of World : "Abstract base class for\nclient and server world\nimplementations with\ndifferent capabilities"

note bottom of WorldTasks : "Manages background\nthreading for world\ngeneration and saving\noperations"

note left of TerrainGenerator : "Plugin architecture\nfor different world\ngeneration algorithms"

@enduml