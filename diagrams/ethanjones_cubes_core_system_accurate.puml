@startuml Core_System_Architecture
!theme plain
title Core System Architecture

    class Branding {
        ~{static} NAME : String
        ~{static} AUTHOR : String
        ~{static} PLATFORM : String
        ~{static} VERSION_HASH : String
        ~{static} VERSION_MAJOR : int
        ~{static} VERSION_MINOR : int
        ~{static} VERSION_POINT : int
        ~{static} VERSION_BUILD : int
        ~{static} VERSION_FULL : String
        ~{static} VERSION_MAJOR_MINOR_POINT : String
        ~{static} VERSION : String
        ~{static} IS_RELEASE : boolean
        ~{static} IS_DEBUG : boolean
        ~{static} DEBUG : String
        ~{static} DATE_FORMAT : DateFormat
        ~{static} DISPLAY_DATE_FORMAT : DateFormat
        ~{static} BUILD_DATE : Date
        ~{static} LAUNCHER : String
        ~properties : Properties
        ~input : InputStream
        +... (more fields)
        --
        ~SimpleDateFormat() : new
        ~SimpleDateFormat(HH:mm:ss" : "yyyy-MM-dd) : new
        ~Properties() : new
        ~if(null : input !=) : void
        ~Properties() : new
        ~if(null : input !=) : void
        ~if(-1 : VERSION_BUILD ==) : void
        ~if() : void
        ~CubesException() : throw new
        ~getFile(file : String) : private static FileHandle
    }
    class CubesException {
        ~{readonly} serialVersionUID : long
        ~{readonly} className : String
        --
        ~get(e : Exception) : public static CubesException
        ~super() : void
        ~super() : void
        ~super() : void
        ~toString() : public String
    }
    class Debug {
        ~{readonly} instance : UncaughtExceptionHandler
        ~{readonly} crashed : AtomicInteger
        ~doAdapterDispose : boolean
        ~{readonly} crashedNum : int
        ~builder : StringBuilder
        ~modStates : List<ModState>
        ~output : StringBuilder
        ~stream : FileInputStream
        ~reader : InputStreamReader
        ~buffer : char[]
        ~length : int
        --
        ~UncaughtExceptionHandler() : new
        ~UncaughtExceptionHandler() : private
        ~uncaughtException(thread : Thread, throwable : Throwable) : Override public void
        ~crash() : void
        ~AtomicInteger() : new
        ~printProperties() : public static void
        ~if(null : Branding.BUILD_DATE !=) : void
        ~lowMemory() : public static synchronized void
        ~criticalMemory() : public static synchronized void
        ~crash(throwable : Throwable) : public static void
        ~synchronized() : void
        ~logCrash() : void
        ~errorExit() : void
        ~logCrash() : void
        ~if() : void
        +... (more methods)
    }
    class UncaughtExceptionHandler {
        ~{readonly} instance : UncaughtExceptionHandler
        --
        ~uncaughtException(thread : Thread, throwable : Throwable) : Override public void
        ~crash() : void
    }
    class Executor {
        ~{static} sync : Object
        ~{static} running : boolean
        ~{static} executor : ScheduledThreadPoolExecutor
        ~{static} scheduled : ArrayList<ScheduledFuture>
        ~{readonly} threadGroup : ThreadGroup
        ~threads : int
        ~t : Thread
        ~t : return
        ~schedule : ScheduledFuture<T>
        ~schedule : return
        ~schedule : return
        ~schedule : return
        ~schedule : return
        ~schedule : ScheduledFuture<T>
        ~schedule : return
        ~schedule : return
        ~schedule : return
        ~schedule : return
        ~null : return
        ~{readonly} side : Side
        +... (more fields)
        --
        ~Object() : new
        ~init() : public static void
        ~synchronized() : void
        ~start() : private static synchronized void
        ~synchronized() : void
        ~ThreadGroup() : new
        ~ScheduledThreadPoolExecutor() : new
        ~newThread(r : Runnable) : public Thread
        ~Thread() : new
        ~execute(callable : Callable<T>) : public static synchronized <T> Future<T>
        ~synchronized() : void
        ~execute(runnable : Runnable) : public static synchronized Future
        ~synchronized() : void
        ~executeNotSided(callable : Callable<T>) : public static synchronized <T> Future<T>
        ~synchronized() : void
        +... (more methods)
    }
    class ExecutorException {
        ~super(thread" : "Exception thrown in executor) : void
    }
    class SidedCallableWrapper {
        ~{readonly} side : Side
        ~{readonly} cubes : Cubes
        ~{readonly} callable : Callable<T>
        ~t : T
        ~t : return
        ~null : return
        --
        ~call() : Override public T
    }
    class SidedRunnableWrapper {
        ~{readonly} side : Side
        ~{readonly} cubes : Cubes
        ~{readonly} runnable : Runnable
        --
        ~run() : Override public void
    }
    class CallableWrapper {
        ~{readonly} callable : Callable<T>
        ~null : return
        --
        ~call() : Override public T
    }
    class RunnableWrapper {
        ~{readonly} runnable : Runnable
        --
        ~run() : Override public void
    }
    class Pools {
        ~{readonly} pools : HashMap<Class, Pool>
        ~obj : T
        ~pool : Pool<T>
        ~pool : Pool<T>
        ~pool : Pool
        ~pool : Pool
        ~null : return
        ~pool : Pool<AreaReference>
        ~pool : Pool
        ~pool : Pool<BlockReference>
        ~pool : Pool
        --
        ~registerType(c : Class<? extends T>, pool : Pool<T>) : public static <T> void
        ~synchronized() : void
        ~obtain(c : Class<T>) : public static <T> T
        ~synchronized() : void
        ~poolExists(c : Class<?>) : public static boolean
        ~clearPool(c : Class<?>) : public static void
        ~synchronized() : void
        ~pool(c : Class<T>) : private static <T> Pool<T>
        ~synchronized() : void
        ~free(c : Class<T>, obj : T) : public static <T> void
        ~synchronized() : void
        ~free(obj : T) : public static <T> void
        ~synchronized() : void
        ~pool(object : Object) : private static Pool
        ~synchronized() : void
        +... (more methods)
    }
    class ThreadPool {
        ~{readonly} name : String
        ~{readonly} runnable : Runnable
        ~{readonly} threads : Thread[]
        -side : Side
        -priority : int
        -daemon : boolean
        -group : ThreadGroup
        ~this : return
        ~this : return
        ~this : return
        ~this : return
        ~this : return
        --
        ~setSide(side : Side) : public ThreadPool
        ~setDaemon(daemon : boolean) : public ThreadPool
        ~setPriority(priority : int) : public ThreadPool
        ~start() : public ThreadPool
        ~ThreadGroup() : new
        ~for() : void
        ~run() : Override public void
        ~stop() : public ThreadPool
        ~stop() : return
        ~stop(safe : boolean) : public ThreadPool
        ~for(threads : Thread thread :) : void
        ~for(threads : Thread thread :) : void
    }
    RuntimeException <|-- CubesException
    Thread.UncaughtExceptionHandler <|.. UncaughtExceptionHandler
    RuntimeException <|-- ExecutorException
    Callable<T> <|.. SidedCallableWrapper
    Runnable <|.. SidedRunnableWrapper
    Callable<T> <|.. CallableWrapper
    Runnable <|.. RunnableWrapper
@enduml
