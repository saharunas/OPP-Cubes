@startuml Save_AFTER_Decorator

title Save System - AFTER Decorator Pattern (3 Levels)

' Style
skinparam classAttributeIconSize 0
skinparam classFontSize 12
skinparam packageStyle rectangle

package "Decorator Pattern - Component" {
    interface SaveInterface <<Component>> {
        + writeArea(area: Area): boolean
        + writeAreas(areas: AreaMap): void
        + readArea(x: int, z: int): Area
        + writePlayer(player: Player): void
        + writePlayers(): void
        + readPlayer(uuid: UUID, clientId): Player
        + writeCave(areaRef, cave): void
        + readCave(areaRef): Cave
        + getSaveOptions(): SaveOptions
        + writeSaveOptions(): SaveOptions
        + getName(): String
        + getFileHandle(): FileHandle
        + isReadOnly(): boolean
        + folderArea(): FileHandle
        + folderCave(): FileHandle
        + folderPlayer(): FileHandle
    }
}

package "Concrete Component" {
    class BasicSave <<ConcreteComponent>> {
        - save: Save
        --
        + BasicSave(save: Save)
        + BasicSave(name, fileHandle)
        + BasicSave(name, fileHandle, readOnly)
        --
        + writeArea(area): boolean
        + readArea(x, z): Area
        + writePlayer(player): void
        + readPlayer(uuid, clientId): Player
        + writeCave(areaRef, cave): void
        + readCave(areaRef): Cave
        .. (delegates to wrapped Save) ..
        + getWrappedSave(): Save
    }
}

package "Abstract Decorator" {
    abstract class SaveDecorator <<Decorator>> {
        # wrappedSave: SaveInterface
        --
        + SaveDecorator(wrappedSave)
        --
        + writeArea(area): boolean
        + readArea(x, z): Area
        + writePlayer(player): void
        + readPlayer(uuid, clientId): Player
        + writeCave(areaRef, cave): void
        + readCave(areaRef): Cave
        .. (delegates to wrappedSave) ..
    }
}

package "Concrete Decorators" {
    class LoggingSaveDecorator <<ConcreteDecorator - Level 1>> {
        + LoggingSaveDecorator(wrappedSave)
        --
        + writeArea(area): boolean
        + readArea(x, z): Area
        + writePlayer(player): void
        + readPlayer(uuid, clientId): Player
        + writeCave(areaRef, cave): void
        + readCave(areaRef): Cave
        .. Adds logging before/after operations ..
    }
    
    class CachingSaveDecorator <<ConcreteDecorator - Level 2>> {
        - areaCache: Map<String, Area>
        - caveCache: Map<String, Cave>
        - playerCache: Map<UUID, Player>
        - maxCacheSize: int
        --
        + CachingSaveDecorator(wrappedSave)
        + CachingSaveDecorator(wrappedSave, maxSize)
        --
        + writeArea(area): boolean
        + readArea(x, z): Area
        + writePlayer(player): void
        + readPlayer(uuid, clientId): Player
        + writeCave(areaRef, cave): void
        + readCave(areaRef): Cave
        --
        + clearCache(): void
        + getCacheStats(): String
        .. LRU cache with automatic eviction ..
    }
    
    class PerformanceSaveDecorator <<ConcreteDecorator - Level 3>> {
        - operationStats: Map<String, OperationStats>
        - logSlowOperations: boolean
        - slowOperationThresholdMs: long
        --
        + PerformanceSaveDecorator(wrappedSave)
        + PerformanceSaveDecorator(wrappedSave, logSlow, threshold)
        --
        + writeArea(area): boolean
        + readArea(x, z): Area
        + writePlayer(player): void
        + readPlayer(uuid, clientId): Player
        + writeCave(areaRef, cave): void
        + readCave(areaRef): Cave
        --
        + logPerformanceStats(): void
        + getPerformanceStats(): Map
        + resetStats(): void
        .. Measures execution time and tracks statistics ..
    }
    
    class PerformanceSaveDecorator::OperationStats {
        - totalTime: long
        - count: long
        - minTime: long
        - maxTime: long
        --
        + record(time: long): void
        + getAverageTime(): double
    }
}

package "Original Classes" {
    class Save {
        + name: String
        + fileHandle: FileHandle
        + readOnly: boolean
        - saveOptions: SaveOptions
        --
        (original implementation)
    }
}

package "Usage Example" {
    class SaveDecoratorExample <<Factory>> {
        {static} + createFullyDecoratedSave(name, fileHandle): SaveInterface
        {static} + createProductionSave(name, fileHandle): SaveInterface
        {static} + createDebugSave(name, fileHandle): SaveInterface
        {static} + createCachedSave(name, fileHandle): SaveInterface
        {static} + createBasicSave(name, fileHandle): SaveInterface
        {static} + createConfigurableSave(...): SaveInterface
    }
}

' Relationships - Pattern Structure
SaveInterface <|.. BasicSave
SaveInterface <|.. SaveDecorator
SaveDecorator <|-- LoggingSaveDecorator
SaveDecorator <|-- CachingSaveDecorator
SaveDecorator <|-- PerformanceSaveDecorator
SaveDecorator o-right-> SaveInterface : wraps
BasicSave *--> Save : wraps
PerformanceSaveDecorator +-- PerformanceSaveDecorator::OperationStats

' Usage relationships
SaveDecoratorExample ..> SaveInterface : creates
SaveDecoratorExample ..> BasicSave : creates
SaveDecoratorExample ..> LoggingSaveDecorator : creates
SaveDecoratorExample ..> CachingSaveDecorator : creates
SaveDecoratorExample ..> PerformanceSaveDecorator : creates

note right of SaveInterface
  **Component Interface**
  
  Defines operations that can
  be decorated with additional
  responsibilities
end note

note right of SaveDecorator
  **Abstract Decorator**
  
  Maintains reference to
  SaveInterface component.
  Delegates all operations
  by default.
end note

note bottom of LoggingSaveDecorator
  **Level 1: Logging**
  
  • Logs all read/write operations
  • Logs success/failure results
  • Useful for debugging
end note

note bottom of CachingSaveDecorator
  **Level 2: Caching**
  
  • LRU cache for areas/caves/players
  • Avoids disk I/O for frequent reads
  • Significant performance improvement
  • Auto-eviction when cache is full
end note

note bottom of PerformanceSaveDecorator
  **Level 3: Performance Monitoring**
  
  • Measures execution time
  • Tracks min/max/average times
  • Counts operation frequency
  • Logs slow operations (>threshold)
  • Identifies bottlenecks
end note

note right of SaveDecoratorExample
  **Factory for creating decorated saves**
  
  Example composition (3 levels):
  
  Performance(
    Caching(
      Logging(
        BasicSave
      )
    )
  )
  
  Each decorator adds responsibility
  without modifying existing code!
end note

note as N1
  **Benefits of Decorator Pattern:**
  
  ✓ Add responsibilities dynamically
  ✓ Combine decorators in any order
  ✓ No subclass explosion
  ✓ Open/Closed Principle
  ✓ Single Responsibility Principle
  ✓ Can enable/disable features at runtime
  
  **Without decorators, you'd need:**
  7+ subclasses for all combinations!
  - SaveWithLogging
  - SaveWithCaching
  - SaveWithPerformance
  - SaveWithLoggingAndCaching
  - SaveWithLoggingAndPerformance
  - SaveWithCachingAndPerformance
  - SaveWithAll
end note

@enduml
