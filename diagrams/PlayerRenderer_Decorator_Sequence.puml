@startuml PlayerRenderer_Decorator_Sequence
title Player Renderer Decorator Pattern - Execution Flow
skinparam sequenceMessageAlign center

actor "Rendering\nEngine" as Engine
participant ":ToolRendererDecorator\n(Level 3)" as Tool
participant ":SkinRendererDecorator\n(Level 2)" as Skin
participant ":NameTagRendererDecorator\n(Level 1)" as Name
participant ":BasicPlayerRenderer\n(Base)" as Basic
participant ":Player" as Player

== Initialization ==

Engine -> Player : createPlayerRenderer()
activate Player

Player -> Basic : new BasicPlayerRenderer()
activate Basic
Basic --> Player : basicRenderer
deactivate Basic

Player -> Name : new NameTagRendererDecorator(basicRenderer, this)
activate Name
Name --> Player : nameDecorator
deactivate Name

Player -> Skin : new SkinRendererDecorator(nameDecorator, this)
activate Skin
Skin --> Player : skinDecorator
deactivate Skin

Player -> Tool : new ToolRendererDecorator(skinDecorator, this)
activate Tool
Tool --> Player : toolDecorator
deactivate Tool

Player --> Engine : toolDecorator
deactivate Player

note over Engine, Basic
  **Decorator Stack Created:**
  Tool → Skin → NameTag → Basic
end note

== Rendering Frame ==

Engine -> Tool : getRenderables(renderables, pool, player)
activate Tool

note right of Tool
  **Level 3: Tool Rendering**
  1. Check if tool changed
  2. Build/update tool mesh if needed
  3. Position tool at hand
  4. Apply rotations (+ special axe handling)
end note

Tool -> Skin : wrappedRenderer.getRenderables(renderables, pool, player)
activate Skin

note right of Skin
  **Level 2: Skin Coloring**
  1. Check if skin color changed
  2. Update model material if needed
end note

Skin -> Name : wrappedRenderer.getRenderables(renderables, pool, player)
activate Name

note right of Name
  **Level 1: Name Tag**
  1. Calculate name tag position
  2. Render text billboard above head
end note

Name -> Basic : wrappedRenderer.getRenderables(renderables, pool, player)
activate Basic

note right of Basic
  **Base: Player Model**
  1. Update model instance transform
  2. Add model to renderables
end note

Basic -> Player : position, angle
activate Player
Player --> Basic : position data
deactivate Player

Basic --> Name : (returns)
deactivate Basic

Name --> Skin : (returns)
deactivate Name

Skin --> Tool : (returns)
deactivate Skin

Tool -> Player : getInventory().selectedItemStack()
activate Player
Player --> Tool : itemStack
deactivate Player

alt Tool is ItemTool
  Tool -> Tool : buildToolMesh(itemStack)
  activate Tool
  note right: Creates 2-quad mesh\nwith item texture
  deactivate Tool
  
  Tool -> Tool : updateToolTransform(player, itemStack)
  activate Tool
  note right: Calculates position:\nright + forward + up\n+ rotation (yaw + special axe)
  deactivate Tool
  
  Tool -> renderables : add(toolRenderable)
end

Tool --> Engine : (returns)
deactivate Tool

note over Engine, Basic
  **Final Renderables Array:**
  1. Player model (Basic)
  2. Name tag billboard (NameTag)
  3. Colored skin material (Skin)
  4. Tool at hand (Tool)
  
  All rendered in single frame
end note

== Multiplayer Sync Example ==

Player -> Player : changeHotbarSlot()
activate Player

Player -> Player : inventory.sync()

alt Side.isClient()
  Player -> Engine : sendPacketToServer(PacketPlayerInventory)
  Engine -> Player : (server receives)
  Engine -> Engine : broadcast PacketOtherPlayerInventory to other clients
  Engine -> Player : (other clients update)
end

deactivate Player

note over Player, Engine
  **Network Synchronization:**
  - Client sends inventory change to server
  - Server broadcasts to all other clients
  - Each client's ToolRendererDecorator
    detects item change and rebuilds mesh
end note

@enduml
