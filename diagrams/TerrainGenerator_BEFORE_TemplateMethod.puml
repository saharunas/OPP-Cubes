@startuml TerrainGenerator_BEFORE_TemplateMethod

title Terrain Generator - BEFORE Template Method Pattern
note as N1
  Problem: No defined algorithm structure.
  Each generator implements generate() and features()
  independently with no guarantee of execution order.
  
  Issues:
  - No enforced algorithm skeleton
  - Inconsistent generation workflow
  - Difficult to add common processing steps
  - No clear separation of algorithm vs implementation
end note

abstract class TerrainGenerator {
  + {abstract} generate(area: Area): void
  + {abstract} features(area: Area, world: WorldServer): void
  + {abstract} spawnPoint(world: WorldServer): BlockReference
  + getRainStatus(x: float, z: float, rainTime: float): RainStatus
  + {static} set(area: Area, block: Block, x: int, y: int, z: int, meta: int): void
  + {static} setVisible(area: Area, block: Block, x: int, y: int, z: int, meta: int): void
}

class BasicTerrainGenerator {
  - old: boolean
  + BasicTerrainGenerator(seed: String)
  + generate(area: Area): void
  + features(area: Area, world: WorldServer): void
  + spawnPoint(world: WorldServer): BlockReference
  --
  Implementation:
  Generates flat world with 5 layers
  (bedrock -> stone -> stone -> dirt -> grass)
}

class VoidTerrainGenerator {
  + generate(area: Area): void
  + features(area: Area, world: WorldServer): void
  + spawnPoint(world: WorldServer): BlockReference
  --
  Implementation:
  Generates 5x5 platform at y=96-100
  with one tree at spawn
}

class TestTerrainGenerator {
  + generate(area: Area): void
  + features(area: Area, world: WorldServer): void
  + spawnPoint(world: WorldServer): BlockReference
  --
  Implementation:
  Generates 3D checkerboard pattern
  for testing purposes
}

class SmoothWorld {
  - baseSeed: long
  - height: Feature
  - heightVariation: Feature
  - trees: Feature
  - rain: Feature
  - caves: CaveManager
  + SmoothWorld()
  + SmoothWorld(baseSeed: long)
  + generate(area: Area): void
  + features(area: Area, world: WorldServer): void
  + spawnPoint(world: WorldServer): BlockReference
  + getRainStatus(x: float, z: float, rainTime: float): RainStatus
  - getSurfaceHeight(x: int, z: int): int
  - getDirtHeight(x: int, z: int): int
  - genTree(area: Area, x: int, z: int): void
  --
  Implementation:
  Complex procedural generation with
  noise-based terrain, caves, trees
}

TerrainGenerator <|-- BasicTerrainGenerator
TerrainGenerator <|-- VoidTerrainGenerator
TerrainGenerator <|-- TestTerrainGenerator
TerrainGenerator <|-- SmoothWorld

class WorldTasks {
  + {static} generate(areaRef: AreaReference, world: WorldServer): int
  + {static} features(areaRef: AreaReference, world: WorldServer): int
}

note right of WorldTasks
  WorldTasks calls generate() and features()
  separately in different phases:
  
  1. Generation phase: generator.generate(area)
  2. Features phase: generator.features(area, world)
  
  No guarantee these are called in sequence
  or that both are always called.
end note

WorldTasks ..> TerrainGenerator : uses

class Area {
  + areaX: int
  + areaZ: int
  + blocks: int[]
  + setupArrays(y: int): void
}

class WorldServer {
  + getTerrainGenerator(): TerrainGenerator
  + setArea(area: Area): void
  + getArea(ref: AreaReference, load: boolean): Area
}

TerrainGenerator ..> Area : generates
TerrainGenerator ..> WorldServer : uses

note as N2
  Single Responsibility Principle Violation:
  - Each generator handles both terrain generation
    AND feature placement logic
  - No separation between algorithm structure
    and implementation details
  
  Open/Closed Principle Violation:
  - Adding common pre/post processing steps
    requires modifying all 4 generators
  - Cannot easily add new processing phases
end note

@enduml
