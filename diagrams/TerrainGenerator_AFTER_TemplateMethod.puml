@startuml TerrainGenerator_AFTER_TemplateMethod

title Terrain Generator - AFTER Template Method Pattern
note as N1
  Solution: Template Method Pattern applied
  
  Benefits:
  + Defined algorithm skeleton in generateArea()
  + Enforced execution order: terrain → features → postProcess
  + Easy to add common processing steps (postProcess hook)
  + Clear separation: algorithm (template) vs implementation (hooks)
  + All 4 concrete classes are final (cannot be extended)
end note

abstract class TerrainGenerator <<abstract>> {
  .. Template Method (final) ..
  + <<final>> generateArea(area: Area, world: WorldServer): void
  
  .. Required Hook Method (abstract) ..
  # <<abstract>> generateTerrain(area: Area): void
  
  .. Optional Hook Methods (protected) ..
  # generateCaves(area: Area, world: WorldServer): void
  # generateVegetation(area: Area, world: WorldServer): void
  # generateStructures(area: Area, world: WorldServer): void
  # generateDecorations(area: Area, world: WorldServer): void
  # postProcess(area: Area, world: WorldServer): void
  
  .. Legacy Methods (for backward compatibility) ..
  + <<final>> generate(area: Area): void
  + <<final>> features(area: Area, world: WorldServer): void
  
  .. Other Methods ..
  + <<abstract>> spawnPoint(world: WorldServer): BlockReference
  + getRainStatus(x: float, z: float, rainTime: float): RainStatus
  + <<static>> set(area: Area, block: Block, ...): void
  + <<static>> setVisible(area: Area, block: Block, ...): void
}

note right of TerrainGenerator::generateArea
  **TEMPLATE METHOD** - defines algorithm skeleton:
  
  1. generateTerrain(area)           [required]
     ↓
  2. generateCaves(area, world)      [optional]
     ↓
  3. generateVegetation(area, world) [optional]
     ↓
  4. generateStructures(area, world) [optional]
     ↓
  5. generateDecorations(area, world)[optional]
     ↓
  6. postProcess(area, world)        [optional]
  
  This method is FINAL and cannot be overridden.
  Subclasses override only needed hook methods.
end note

note right of TerrainGenerator::generateTerrain
  **Required hook** - generates base terrain structure
  (blocks, height, ground layers, bedrock, stone, dirt, grass)
  
  MUST be implemented by all subclasses.
end note

note right of TerrainGenerator::generateCaves
  **Optional hook** - generates caves, ravines, 
  underground tunnels and geological features.
  
  Default: no caves (empty implementation)
end note

note right of TerrainGenerator::generateVegetation
  **Optional hook** - generates trees, grass, flowers,
  plants and all organic surface features.
  
  Default: no vegetation (empty implementation)
end note

note right of TerrainGenerator::generateStructures
  **Optional hook** - generates buildings, ruins, villages,
  temples and artificial structures.
  
  Default: no structures (empty implementation)
end note

note right of TerrainGenerator::generateDecorations
  **Optional hook** - generates ores, special blocks,
  surface details and decorative elements.
  
  Default: no decorations (empty implementation)
end note

note right of TerrainGenerator::postProcess
  **Optional hook** - applies final post-processing:
  lighting updates, validation, cleanup.
  
  Default: do nothing (empty implementation)
end note

class BasicTerrainGenerator <<final>> {
  - old: boolean
  + BasicTerrainGenerator(seed: String)
  # generateTerrain(area: Area): void
  + spawnPoint(world: WorldServer): BlockReference
  --
  **Hook implementations:**
  ✓ generateTerrain() - 5 layers: bedrock/stone/stone/dirt/grass
  ✗ generateCaves() - not overridden (no caves)
  ✗ generateVegetation() - not overridden (no trees)
  ✗ generateStructures() - not overridden
  ✗ generateDecorations() - not overridden
  ✗ postProcess() - not overridden
  
  Result: Simple flat world, no features
}

class VoidTerrainGenerator <<final>> {
  # generateTerrain(area: Area): void
  # generateVegetation(area: Area, world: WorldServer): void
  + spawnPoint(world: WorldServer): BlockReference
  --
  **Hook implementations:**
  ✓ generateTerrain() - 5x5 platform at y=96-100
  ✗ generateCaves() - not overridden (no caves)
  ✓ generateVegetation() - single tree at spawn (2,101,2)
  ✗ generateStructures() - not overridden
  ✗ generateDecorations() - not overridden
  ✗ postProcess() - not overridden
  
  Result: Void world with small platform + 1 tree
}

class TestTerrainGenerator <<final>> {
  # generateTerrain(area: Area): void
  + spawnPoint(world: WorldServer): BlockReference
  --
  **Hook implementations:**
  ✓ generateTerrain() - 3D checkerboard pattern
  ✗ generateCaves() - not overridden (no caves)
  ✗ generateVegetation() - not overridden (no trees)
  ✗ generateStructures() - not overridden
  ✗ generateDecorations() - not overridden
  ✗ postProcess() - not overridden
  
  Result: Checkerboard test pattern, no features
}

class SmoothWorld <<final>> {
  - baseSeed: long
  - height: Feature
  - heightVariation: Feature
  - trees: Feature
  - rain: Feature
  - caves: CaveManager
  + SmoothWorld()
  + SmoothWorld(baseSeed: long)
  # generateTerrain(area: Area): void
  # generateCaves(area: Area, world: WorldServer): void
  # generateVegetation(area: Area, world: WorldServer): void
  + spawnPoint(world: WorldServer): BlockReference
  + getRainStatus(x: float, z: float, rainTime: float): RainStatus
  - getSurfaceHeight(x: int, z: int): int
  - getDirtHeight(x: int, z: int): int
  - genTree(area: Area, x: int, z: int): void
  --
  **Hook implementations:**
  ✓ generateTerrain() - noise-based height + caves.apply()
  ✓ generateCaves() - caves already in terrain (empty hook)
  ✓ generateVegetation() - trees via noise distribution
  ✗ generateStructures() - not overridden
  ✗ generateDecorations() - not overridden (could add ores)
  ✗ postProcess() - not overridden
  
  Result: Complex procedural world with terrain/caves/trees
}

TerrainGenerator <|-- BasicTerrainGenerator
TerrainGenerator <|-- VoidTerrainGenerator
TerrainGenerator <|-- TestTerrainGenerator
TerrainGenerator <|-- SmoothWorld

class WorldTasks {
  + {static} generate(areaRef: AreaReference, world: WorldServer): int
  + {static} features(areaRef: AreaReference, world: WorldServer): int
}

note right of WorldTasks
  Backward compatibility maintained:
  
  Legacy code still calls:
  - generator.generate(area)
    → internally calls generateTerrain()
  
  - generator.features(area, world)
    → internally calls generateFeatures()
  
  New code can use:
  - generator.generateArea(area, world)
    → executes full template method
end note

WorldTasks ..> TerrainGenerator : uses

class Area {
  + areaX: int
  + areaZ: int
  + blocks: int[]
  + setupArrays(y: int): void
}

class WorldServer {
  + getTerrainGenerator(): TerrainGenerator
  + setArea(area: Area): void
  + getArea(ref: AreaReference, load: boolean): Area
}

TerrainGenerator ..> Area : generates
TerrainGenerator ..> WorldServer : uses

note as N2
  Template Method Pattern Benefits:
  
  ✓ Single Responsibility Principle:
    - Algorithm structure (template) separated
      from implementation (hooks)
    - Each concrete class implements only
      terrain/features logic
  
  ✓ Open/Closed Principle:
    - Adding new processing steps (e.g., postProcess)
      doesn't require modifying concrete classes
    - Can override postProcess() hook if needed
  
  ✓ DRY (Don't Repeat Yourself):
    - Common algorithm structure defined once
    - No duplicate generation workflow code
  
  ✓ Type Safety:
    - All concrete classes are final
    - Cannot accidentally extend and break pattern
end note

note as N3
  Example Usage:
  
  // Old way (still works):
  generator.generate(area);
  generator.features(area, world);
  
  // New way (recommended):
  generator.generateArea(area, world);
  
  // Execution flow (6 steps):
  1. generateTerrain() - base terrain structure
  2. generateCaves() - geological features
  3. generateVegetation() - trees, plants
  4. generateStructures() - buildings, ruins
  5. generateDecorations() - ores, details
  6. postProcess() - final cleanup
end note

note as MATRIX
  **Hook Implementation Matrix**
  
  | Generator | Terrain | Caves | Vegetation | Structures | Decorations |
  |-----------|---------|-------|------------|------------|-------------|
  | Basic     |    ✓    |   ✗   |     ✗      |     ✗      |      ✗      |
  | Void      |    ✓    |   ✗   |     ✓      |     ✗      |      ✗      |
  | Test      |    ✓    |   ✗   |     ✗      |     ✗      |      ✗      |
  | Smooth    |    ✓    |   ✓   |     ✓      |     ✗      |      ✗      |
  
  ✓ = Overridden (custom implementation)
  ✗ = Default (empty implementation)
end note

@enduml
