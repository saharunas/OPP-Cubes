@startuml World_and_Map_System
!theme plain
title World and Map System

    class CoordinateConverter {
        ~SIZE_BLOCKS_POW2 : return position >>
        --
        ~block(position : float) : public static int
        ~area(position : float) : public static int
        ~area(position : int) : public static int
    }
    class AreaMap {
        ~{readonly} map : LongMap<Area>
        ~{readonly} sorted : ArrayList<Area>
        ~modifiedSinceSort : boolean
        ~{readonly} world : World
        --
        ~super() : void
        ~getArea(areaX : int, areaZ : int) : public Area
        ~lockedGetArea(areaX : int, areaZ : int) : public Area
        ~setArea(areaX : int, areaZ : int, area : Area) : public boolean
        ~iterator() : public AreaIterator
        ~toString() : public String
    }
    class Entities {
        ~{readonly} world : World
        ~{readonly} map : HashMap<UUID, Entity>
        --
        ~super() : void
        ~getEntitiesForSave(areaX : int, areaZ : int) : public DataGroup[]
        ~addEntity(entity : Entity) : public void
        ~removeEntity(entity : Entity) : public boolean
    }
    class Area {
        ~{readonly} SIZE_BLOCKS : int
        ~{readonly} SIZE_BLOCKS_SQUARED : int
        ~{readonly} SIZE_BLOCKS_CUBED : int
        ~{readonly} areaX : int
        ~{readonly} areaZ : int
        ~{readonly} minBlockX : int
        ~{readonly} minBlockZ : int
        +blocks : int[]
        +light : byte[]
        +heightmap : int[]
        +areaRenderer : AreaRenderer[]
        +maxY : int
        +height : int
        +blockDataList : ArrayList<BlockData>
        --
        ~super() : void
        ~getBlock(x : int, y : int, z : int) : public Block
        ~setBlock(block : Block, x : int, y : int, z : int, meta : int) : public boolean
        ~getMeta(x : int, y : int, z : int) : public int
        ~getSunlight(x : int, y : int, z : int) : public int
        ~getLight(x : int, y : int, z : int) : public int
        ~modify() : public void
        ~isReady() : public boolean
    }
    class Save {
        ~{readonly} name : String
        ~{readonly} fileHandle : FileHandle
        ~{readonly} readOnly : boolean
        -saveOptions : SaveOptions
        --
        ~super() : void
        ~writeArea(area : Area) : public boolean
        ~writeAreas(areas : AreaMap) : public void
        ~readArea(x : int, z : int) : public Area
        ~getSaveOptions() : public SaveOptions
        ~writeSaveOptions() : public void
        ~writePlayer(player : Player) : public void
        ~readPlayer(uuid : UUID, clientIdentifier : ClientIdentifier) : public Player
    }
    class SaveOptions {
        +worldSeed : long
        +worldSeedString : String
        +worldTime : int
        +worldPlayingTime : long
        +worldType : String
        +worldGamemode : Gamemode
        +idManager : DataGroup
        +worldRainOverride : RainStatus
        --
        ~write() : public DataGroup
        ~read(dataGroup : DataGroup) : public void
        ~setWorldSeed(seedString : String) : public void
    }
    class AreaReference {
        +areaX : int
        +areaZ : int
        -hashCode : int
        --
        ~setFromArea(area : Area) : public AreaReference
        ~setFromAreaCoordinates(areaX : int, areaZ : int) : public AreaReference
        ~setFromBlockCoordinates(blockX : int, blockZ : int) : public AreaReference
        ~setFromPosition(x : float, z : float) : public AreaReference
        ~offset(areaX : int, areaZ : int) : public AreaReference
        ~minBlockX() : public int
        ~minBlockZ() : public int
    }
    enum Side {
        Client
        Server
        --
    }
    class Entity {
        ~{static} GRAVITY : float
        +uuid : UUID
        +height : float
        ~{readonly} position : Vector3
        ~{readonly} angle : Vector3
        ~{readonly} motion : Vector3
        ~{readonly} id : String
        --
        ~update() : public boolean
        ~write() : public DataGroup
        ~read(dataGroup : DataGroup) : public void
        ~dispose() : public void
    }
    class WorldServer {
        -loadedAreaFilters : List<LoadedAreaFilter>
        -rainStatusOverride : RainStatus
        -rainStatusOverrideEnd : long
        --
        ~super() : void
        ~getSpawnPoint() : public BlockReference
        ~tick() : public void
        ~shouldAreaBeLoaded(areaReference : AreaReference) : public boolean
        ~requestRegion(references : MultiAreaReference, parameter : WorldRequestParameter) : public GenerationTask
        ~save() : public void
    }
    abstract class World {
        ~{readonly} MAX_TIME : int
        ~{readonly} map : AreaMap
        ~{readonly} entities : Entities
        ~{readonly} terrainGenerator : TerrainGenerator
        ~{readonly} save : Save
        ~{readonly} side : Side
        #time : int
        #playingTime : long
        ~{readonly} disposed : AtomicBoolean
        ~{readonly} lua : LuaTable
        ~area : Area
        ~area : return
        ~area : Area
        ~area : return
        ~area : Area
        ~area : return
        ~area : Area
        ~area : return
        ~area : Area
        ~area : return
        +... (more fields)
        --
        ~AtomicBoolean() : new
        ~super() : void
        ~AreaMap() : new
        ~Entities() : new
        ~setArea(area : Area) : public boolean
        ~IllegalArgumentException() : throw new
        ~setArea() : return
        ~setArea(areaX : int, areaZ : int, area : Area) : public boolean
        ~heightmap(x : int, z : int) : public int
        ~getBlock(x : int, y : int, z : int) : public Block
        ~getBlockData(x : int, y : int, z : int) : public BlockData
        ~getMeta(x : int, y : int, z : int) : public int
        ~getLight(x : int, y : int, z : int) : public int
        ~getSunLight(x : int, y : int, z : int) : public int
        ~getLightRaw(x : int, y : int, z : int) : public int
        +... (more methods)
    }
    class ClientSaveManager {
        ~clientSavesFolder : FileHandle
        ~list : FileHandle[]
        ~saves : Save[]
        ~saves : return
        ~folder : FileHandle
        ~handle : FileHandle
        ~s : Save
        ~options : SaveOptions
        ~s : return
        ~s : Save
        ~options : SaveOptions
        ~s : return
        --
        ~getSavesFolder() : public static FileHandle
        ~getSaves() : public static Save[]
        ~for() : void
        ~createSave(name : String, generatorID : String, gamemode : Gamemode, seedString : String) : public static Save
        ~Save() : new
        ~SaveOptions() : new
        ~createTemporarySave(generatorID : String, gamemode : Gamemode, seedString : String) : public static Save
        ~Save() : new
        ~SaveOptions() : new
        ~deleteSave(save : Save) : public static void
    }
    class WorldClient {
        -removed : ArrayList<Area>
        -playerArea : AreaReference
        ~{readonly} renderDistance : int
        +rainStatus : RainStatus
        -tickCounter : int
        ~areaIterator : Iterator<Area>
        ~area : Area
        ~dist : int
        ~entityIterator : Iterator<Entry<UUID, Entity>>
        ~entry : Entry<UUID, Entity>
        ~entity : Entity
        ~aX : int
        ~aZ : int
        ~dist : int
        ~light : float
        ~null : return
        --
        ~AreaReference() : new
        ~super() : void
        ~tick() : Override public void
        ~if() : void
        ~if() : else
        ~if() : void
        ~for(removed : Area area :) : void
        ~getSkyColour() : public Color
        ~dispose() : Override public void
        ~requestRegion(references : MultiAreaReference, parameter : WorldRequestParameter) : Override public GenerationTask
    }
    class BlockIntersection {
        ~{readonly} blockReference : BlockReference
        ~{readonly} blockFace : BlockFace
        ~{readonly} block : Block
        ~{readonly} blockMeta : int
        ~{readonly} rayLength : float
        ~blockReference : return
        ~blockFace : return
        ~block : return
        ~blockMeta : return
        ~rayLength : return
        ~blockReference : BlockReference
        ~stepZ : int stepX, stepY,
        ~rayLength : float tMaxX, tMaxY, tMaxZ, tDeltaX, tDeltaY, tDeltaZ,
        ~side : XYZ
        ~block : Block
        ~blockFace : BlockFace
        ~blockMeta : int
        ~null : return
        --
        ~getBlockReference() : public BlockReference
        ~getBlockFace() : public BlockFace
        ~getBlock() : public Block
        ~getBlockMeta() : public int
        ~getRayLength() : public float
        ~getBlockIntersection(origin : Vector3, direction : Vector3, world : World) : public static BlockIntersection
        ~intersection() : return
        ~intersection(origin : Vector3, direction : Vector3, radius : int, world : World) : public static BlockIntersection
        ~if() : void
        ~if() : else
        ~if() : void
        ~if() : else
        ~if() : void
        ~if() : else
        ~if() : void
        +... (more methods)
    }
    enum XYZ {
    }
    class PlayerCollision {
        -world : World
        ~{readonly} r : float
        ~player : Player
        ~pos : Vector3
        ~blockX : int
        ~blockZ : int
        ~minBlockY : int
        ~maxBlockY : int
        ~x : int
        ~y : int
        ~z : int
        --
        ~preventNoclip(event : PlayerMovementEvent) : EventHandler public void
        ~for() : void
        ~limit() : void
        ~limit() : void
        ~limit() : void
        ~limit() : void
        ~check(position : Vector3, xOffset : float, yOffset : float, zOffset : float) : private boolean
        ~limit(newPos : Vector3, xOffset : float, zOffset : float, height : float) : private void
    }
    class BasicTerrainGenerator {
        ~old : boolean
        --
        ~generate(area : Area) : Override public void
        ~for() : void
        ~for() : void
        ~set() : void
        ~set() : void
        ~set() : void
        ~set() : void
        ~set() : void
        ~if(old : area.areaX == 0 && area.areaZ == 0 &&) : void
        ~set() : void
        ~set() : void
        ~set() : void
        ~set() : void
        ~features(area : Area, world : WorldServer) : Override public void
        ~spawnPoint(world : WorldServer) : Override public BlockReference
    }
    class GeneratorManager {
        ~{readonly} generators : LinkedHashMap<String, TerrainGeneratorFactory>
        ~factory : TerrainGeneratorFactory
        ~strings : Set<String>
        --
        ~TerrainGeneratorFactory() : , new
        ~getTerrainGenerator(saveOptions : SaveOptions) : Override public TerrainGenerator
        ~SmoothWorld() : return new
        ~TerrainGeneratorFactory() : , new
        ~getTerrainGenerator(saveOptions : SaveOptions) : Override public TerrainGenerator
        ~BasicTerrainGenerator() : return new
        ~TerrainGeneratorFactory() : , new
        ~getTerrainGenerator(saveOptions : SaveOptions) : Override public TerrainGenerator
        ~TestTerrainGenerator() : return new
        ~TerrainGeneratorFactory() : , new
        ~getTerrainGenerator(saveOptions : SaveOptions) : Override public TerrainGenerator
        ~VoidTerrainGenerator() : return new
        ~register(str : String, generator : TerrainGeneratorFactory) : public static void
        ~NullPointerException() : throw new
        ~IllegalStateException(registered" : str + " has already been) : throw new
        +... (more methods)
    }
    interface TerrainGeneratorFactory {
        ~getTerrainGenerator(saveOptions : SaveOptions) : TerrainGenerator
    }
    class RainStatus {
        ~{readonly} NOT_RAINING : RainStatus
        ~{readonly} raining : boolean
        ~{readonly} rainRate : float
        --
        ~toString() : Override public String
        ~if() : void
    }
    abstract class TerrainGenerator {
        ~ref : int
        ~a : Area
        ~ref : int
        ~a : Area
        --
        ~generate(area : Area) : public abstract void
        ~features(area : Area, world : WorldServer) : public abstract void
        ~spawnPoint(world : WorldServer) : public abstract BlockReference
        ~getRainStatus(x : float, z : float, rainTime : float) : public RainStatus
        ~set(area : Area, block : Block, x : int, y : int, z : int, meta : int) : public static void
        ~setNeighbour(area : Area, block : Block, x : int, y : int, z : int, meta : int) : public static void
        ~set(a.minBlockX : x -, a.minBlockZ : z -) : void
        ~setVisible(area : Area, block : Block, x : int, y : int, z : int, meta : int) : public static void
        ~setVisibleNeighbour(area : Area, block : Block, x : int, y : int, z : int, meta : int) : public static void
        ~setVisible(a.minBlockX : x -, a.minBlockZ : z -) : void
    }
    class TestTerrainGenerator {
        ~generate(area : Area) : Override public void
        ~for() : void
        ~for() : void
        ~for() : void
        ~if(0 : y % 2 ==) : void
        ~if(0 : x % 2 ==) : void
        ~if(1 : x % 2 ==) : void
        ~features(area : Area, world : WorldServer) : Override public void
        ~spawnPoint(world : WorldServer) : Override public BlockReference
    }
    class VoidTerrainGenerator {
        ~generate(area : Area) : Override public void
        ~for() : void
        ~for() : void
        ~for() : void
        ~set() : void
        ~set() : void
        ~features(area : Area, world : WorldServer) : Override public void
        ~spawnPoint(world : WorldServer) : Override public BlockReference
    }
    class WorldGravity {
        ~f : float
        ~y : int
        ~b : boolean
        --
        ~getBlockY(pos : Vector3, height : float) : public static int
        ~onBlock(w : World, pos : Vector3, height : float, r : float) : public static boolean
        ~isBlock(world : World, x : float, y : int, z : float) : private static boolean
    }
    class BlockLight {
        ~{readonly} FULL_LIGHT : byte
        ~lightQueue : ArrayDeque<LightNode>
        ~lightQueue : ArrayDeque<LightNode>
        ~n : LightNode
        ~x : int
        ~y : int
        ~z : int
        ~l : int
        ~a : Area
        ~ref : int
        ~removeQueue : ArrayDeque<LightNode>
        ~addQueue : ArrayDeque<LightNode>
        ~prev : int
        ~n : LightNode
        ~x : int
        ~y : int
        ~z : int
        ~l : int
        ~a : Area
        ~ref : int
        +... (more fields)
        --
        ~spreadLight(x : int, y : int, z : int, area : Area, w : LightWorldSection) : public static void
        ~if(area.maxY : y >= 0 && y <=) : void
        ~propagateAdd() : void
        ~addLight(x : int, y : int, z : int, l : int, area : Area, lws : LightWorldSection) : public static void
        ~if(area.maxY : y > 0 && y <=) : void
        ~propagateAdd() : void
        ~propagateAdd(lightQueue : ArrayDeque<LightNode>, w : LightWorldSection) : private static void
        ~tryPropagateAdd(1 : x -) : void
        ~tryPropagateAdd(1 : x +) : void
        ~tryPropagateAdd(1 : z -) : void
        ~tryPropagateAdd(1 : z +) : void
        ~tryPropagateAdd(1 : y +) : void
        ~tryPropagateAdd(lightQueue : ArrayDeque<LightNode>, w : LightWorldSection, x : int, y : int, z : int, l : int) : private static void
        ~removeLight(x : int, y : int, z : int, area : Area, lws : LightWorldSection) : public static void
        ~if(area.maxY : y > 0 && y <=) : void
        +... (more methods)
    }
    class LightNode {
        +x : int
        +y : int
        +z : int
        +l : int
    }
    class LightWorldSection {
        ~{readonly} initialAreaX : int
        ~{readonly} initialAreaZ : int
        ~{readonly} initialMinBlockX : int
        ~{readonly} initialMinBlockZ : int
        ~{readonly} initialMaxBlockX : int
        ~{readonly} initialMaxBlockZ : int
        ~{readonly} areas : Area[]
        ~{readonly} initial : Area
        -lock : Locked<Area>
        ~dX : int
        ~dZ : int
        ~a : Area
        ~ref : int
        ~a : Area
        ~a : Area
        ~a : Area
        ~b : int
        ~blockID : int
        ~blockMeta : int
        --
        ~for(areas : Area area :) : void
        ~AreaNotLoadedException() : throw new
        ~getArea(areaX : int, areaZ : int) : public Area
        ~transparent(x : int, y : int, z : int) : protected boolean
        ~getSunlight(x : int, y : int, z : int) : protected int
        ~getLight(x : int, y : int, z : int) : protected int
        ~isLightSource(x : int, y : int, z : int) : protected boolean
        ~maxY(x : int, z : int) : protected int
        ~close() : Override public void
    }
    class SunLight {
        ~{readonly} MAX_SUNLIGHT : int
        ~lightQueue : ArrayDeque<LightNode>
        ~max : int
        ~hmRef : int
        ~h : int
        ~ref : int
        ~r : int
        ~lightQueue : ArrayDeque<LightNode>
        ~n : LightNode
        ~x : int
        ~y : int
        ~z : int
        ~l : int
        ~a : Area
        ~ref : int
        ~i : int
        ~removeQueue : ArrayDeque<LightNode>
        ~addQueue : ArrayDeque<LightNode>
        ~prev : int
        ~n : LightNode
        +... (more fields)
        --
        ~initialSunlight(area : Area) : public static void
        ~for() : void
        ~for() : void
        ~for() : void
        ~propagateAdd() : void
        ~addSunlight(x : int, y : int, z : int, area : Area, w : LightWorldSection) : public static void
        ~if(area.maxY : y > 0 && y <=) : void
        ~propagateAdd() : void
        ~propagateAdd(lightQueue : ArrayDeque<LightNode>, w : LightWorldSection) : private static void
        ~tryPropagateAdd(1 : x -, 1 : l -) : void
        ~tryPropagateAdd(1 : x +, 1 : l -) : void
        ~tryPropagateAdd(1 : z -, 1 : l -) : void
        ~tryPropagateAdd(1 : z +, 1 : l -) : void
        ~tryPropagateAdd(1 : y +, 1 : l -) : void
        ~tryPropagateAdd(lightQueue : ArrayDeque<LightNode>, w : LightWorldSection, x : int, y : int, z : int, ln : int) : private static void
        +... (more methods)
    }
    class WorldLightHandler {
        ~blockReference : BlockReference
        ~oldBlock : Block
        ~newBlock : Block
        ~oldMeta : int
        ~newMeta : int
        ~area : Area
        --
        ~blockChanged(event : BlockChangedEvent) : public void
    }
    ' Inheritance relationships
    WorldLockable <|-- World
    WorldLockable <|-- AreaMap  
    WorldLockable <|-- Entities
    Lockable <|-- Area
    Disposable <|.. World
    Disposable <|.. Entity
    Pool.Poolable <|.. AreaReference
    World <|-- WorldClient
    World <|-- WorldServer
    TerrainGenerator <|-- BasicTerrainGenerator
    TerrainGenerator <|-- TestTerrainGenerator
    TerrainGenerator <|-- VoidTerrainGenerator
    AutoCloseable <|.. LightWorldSection
    
    ' Core World Composition (most critical relationships)
    World *-- AreaMap : contains
    World *-- Entities : contains  
    World *-- TerrainGenerator : uses
    World *-- Save : contains
    World *-- Side : contains
    
    ' AreaMap relationships
    AreaMap *-- "*" Area : manages
    AreaMap --> World : references
    
    ' Entities relationships  
    Entities *-- "*" Entity : contains
    Entities --> World : references
    
    ' Area relationships
    Area --> AreaMap : belongs to
    Area *-- "*" AreaRenderer : rendering
    Area *-- "*" BlockData : block data
    
    ' TerrainGenerator dependencies
    TerrainGenerator ..> Area : generate()
    TerrainGenerator ..> WorldServer : features()
    
    ' WorldClient specific associations
    WorldClient *-- "*" Area : removed areas
    WorldClient --> AreaReference : playerArea
    WorldClient --> RainStatus : current status
    
    ' WorldServer specific
    WorldServer --> "*" LoadedAreaFilter : area filters
    
    ' Save system relationships
    Save *-- SaveOptions : configuration
    Save ..> Area : reads/writes
    Save ..> AreaMap : saves all areas
    ClientSaveManager ..> Save : creates/manages
    
    ' AreaReference relationships
    AreaReference ..> Area : references
    AreaReference ..> CoordinateConverter : uses
    
    ' Collision system
    PlayerCollision --> World : checks blocks
    PlayerCollision --> Entity : player entity
    BlockIntersection ..> World : raycast query
    
    ' Lighting system relationships
    LightWorldSection --> "*" Area : processes
    BlockLight ..> Area : lighting calculations
    SunLight ..> Area : sunlight calculations
    WorldLightHandler --> Area : handles changes
    
    ' Generator management
    GeneratorManager *-- "*" TerrainGeneratorFactory : registry
    TerrainGeneratorFactory ..> TerrainGenerator : creates
    
    ' Gravity and physics
    WorldGravity ..> World : queries blocks
    
    ' Coordinate conversion utilities
    CoordinateConverter ..> Area : coordinate math
@enduml
